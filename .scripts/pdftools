#!/usr/bin/python3
#coding=utf8

#   pdftools - manipulate pdf files
#   Copyright (C) 2015 Raffaele Mancuso
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.


import sys
import zipfile #Used to compress debug files togheter to be sent for analysis
import datetime
import tempfile
import os
import shutil
import argparse
import subprocess
from string import Template
import re

paginate_h = 0.93; paginate_v = 0.96
previous_cwd = os.getcwd() #To restore cwd at the end, otherwise we get a exception
today = datetime.datetime.now()
#-Calculate needed rounds of compilation
needed_comp_rounds = 2 
pdftk=True #will be set to false if not found

#return 'pdf' if it's a pdf file, 'img' if it's an image file, or 'unknown' if it is not recognized
def getFileType(filepath):
	curr_ext = os.path.splitext(filepath)[1]
	if curr_ext=='.pdf':
		return 'pdf'
	elif curr_ext=='.jpg' or curr_ext=='.jpeg' or curr_ext=='.gif' or curr_ext=='.png' or curr_ext=='.bmp':
		return 'img'
	else:
		return 'unknown'
			
#Natural sorting. See http://stackoverflow.com/questions/5967500/how-to-correctly-sort-a-string-with-a-number-inside
def atoi(text):
	return int(text) if text.isdigit() else text

def natural_keys(text):
	'''
	alist.sort(key=natural_keys) sorts in human order
	http://nedbatchelder.com/blog/200712/human_sorting.html
	(See Toothy's implementation in the comments)
	'''
	return [ atoi(c) for c in re.split('(\d+)', text) ]

def repairPdfFile(filepath):
	repaired_path = os.path.splitext(filepath)[0] + "_repaired.pdf"
	cmd = "pdftk \""+args.input[i]+"\" output \"" + repaired_path + "\""
	print("Running: \""+cmd+"\"")
	subprocess.call(cmd)
	return repaired_path
				
#Reads a list of pages to extract from a file. Used with the --extract-pages option
def readListFromFile(filename):
	filename = os.path.join(previous_cwd,filename)
	if os.path.isfile(filename)==False:
		exit_with_code("List file \"" + filename+"\" not found",1)
	f = open(filename,'r')
	l = list()
	for line in f:
		slt_list = line.replace('\n','').split(' ')
		for slt in slt_list:
			l.append(int(slt))
	return l

#Check the presence of a single Latex package
def checkLatexPackageCLI(pkgname):
	res = checkLatexPackage(pkgname)
	if (res == False):
		print("Checking "+pkgname+": MISSING")
	else:
		print("Checking "+pkgname+": found")

def checkLatexPackage(pkgname):
	latex_file_name = "check.tex"	
	latex_script = "\\documentclass{article} \
	\n\\usepackage{"+pkgname+"} \
	\n\\begin{document}\
	\nHello\
	\n\\end{document}"
	#Write latex file
	latex_file = open(latex_file_name,"w")
	latex_file.write(latex_script)
	latex_file.close()	
	#Compile latex file
	latex_return = subprocess.call( ["pdflatex","--interaction=batchmode",""+latex_file_name] , stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
	removeFile("check.tex")
	removeFile("check.pdf")
	removeFile("check.aux")
	removeFile("check.log")
	if latex_return != 0:
		return False
	return True
	
#Check that the current Latex installation has all the required packages
def checkLatexInstallation():	
	checkLatexPackageCLI("pdfpages")
	checkLatexPackageCLI("lastpage")
	checkLatexPackageCLI("grffile")
	checkLatexPackageCLI("forloop")
	checkLatexPackageCLI("fancyhdr")
	checkLatexPackageCLI("textpos")
	checkLatexPackageCLI("changepage")
	checkLatexPackageCLI("graphicx")
	checkLatexPackageCLI("THIS_PACKAGE_DOES_NOT_EXIST")

def removeFile(filename):
	if(os.path.isfile(filename)):
		os.remove(filename)
		
#Open a file with the OS default application
#Credit: http://stackoverflow.com/questions/434597/open-document-with-default-application-in-python
def openFile(filepath): 
	if sys.platform.startswith('darwin'):
		subprocess.call(('open', filepath))
	elif os.name == 'nt':
		os.startfile(filepath)
	elif os.name == 'posix':
		filepath = filepath.replace('"', '')
		subprocess.call( ["xdg-open", filepath] )

def exit_with_code(msg, code):
	os.chdir(previous_cwd) #Avoid a permission error exception caused by the fact Python wants to delete the temporary folder
	if msg != "":
		print(msg)
	exit(code)

#Convert an array into a string
#Used to convert command line passed arrays, like "delta", "offset" options
def arrayToString(arr, ldelim = "", rdelim=""):
	ostr = ""
	for i in range(0, len(arr)):
		ostr += ldelim + str(arr[i]) + rdelim + " "
	return ostr

def linuxize(str):
	return str.replace("\\","/")

def printTextHelp():
	#text_proc = Template(text[0]).substitute(day=today.day, month=today.month, year=today.year, page=r'\thepage', pages=r'\pageref{LastPage}', filename=file_basename)
	print("Prepend this variables with a $ sign (e.g. $day) \
		\nday = day of today \
		\nmonth = today month \
		\nyear = today year \
		\npage = current page \
		\npages = total number of pages \
		\nfilename = input pdf filename (without path and without extension} ")
		
#The core of the software
def run(args):
	pre_include_pdf = ""
	post_include_pdf = ""
	
	if(args.check_latex):
		checkLatexInstallation()
		exit_with_code("Exiting",1)
	if(args.debug_print):
		print(args)
		exit_with_code("debug mode exit", 1)
	
	#debug-no-compile implies debug
	if args.debug_no_compile or args.debug_folder != 'temp':
		args.debug = True
	
	if(args.repair and pdftk==False):
		exit_with_code("ERROR: You need pdftk to repair files")
		
	# ****Process options got from command line****
	
	#1. Check PDF input files
	input_pdf_files = []
	input_img_files = []
	for i in range(len(args.input)):
		#-Process directory, walk through every file in it-
		if(os.path.isdir(args.input[i])): 
			for root, dirs, files in os.walk(args.input[i]):
				if args.natural_sorting:
					print("Using natural sorting algorithm...")
					files.sort(key=natural_keys)
				else:
					files.sort()
				for currfile in files:
					type = getFileType(args.input[i])
					#Add pdf file
					if type=='pdf':
						input_pdf_files.append( os.path.abspath(os.path.join(root,currfile)) ) 
						if args.verbose == True:
							print("Adding PDF file from directory: \"" + currfile + "\"")							
					#Add image file	
					elif type=='img':
						input_img_files.append( os.path.abspath(os.path.join(root,currfile)) ) 
						if(args.verbose):
							print("Adding image file from directory: \"" + currfile + "\"")			
					else:
						exit_with_code("ERROR: unrecognized file type for "+args.input[i])			
						
		#-Process file-
		elif ( os.path.isfile(args.input[i]) ):
			type = getFileType(args.input[i])
			if(type=='pdf'):
				if(args.repair): #repair the file
					args.input[i] = repairPdfFile(args.input[i])
				input_pdf_files.append( os.path.abspath(args.input[i]) )
				if args.verbose == True:
							print("Adding PDF file: \"" + args.input[i] + "\"")
			elif type=='img':
				input_img_files.append( os.path.abspath(args.input[i]) )
				if args.verbose == True:
					print("Adding image file: \"" + args.input[i] + "\"")
			else:
				exit_with_code("ERROR: unrecognized extension for "+args.input[i])
		else:
			exit_with_code("FATAL ERROR: Input file \"" + args.input[i] + "\" doesn't exist.", 1)
	
	#2. Check output file
	if(args.output==None): #If no output file was specified, append "args.out_suffix" to the first input file name
		args.output = os.path.splitext(input_pdf_files[0])[0] + args.out_suffix + ".pdf"
	args.output = os.path.abspath(args.output) #To make shutil.copy happy
	if(os.path.isfile(args.output)==True): #Check that output pdf file doesn't exist yet
		if args.overwrite:
			os.remove(args.output)
		else:
			exit_with_code("FATAL ERROR: File \""+args.output+"\" already exists. Use --overwrite if you want to overwrite it", 1)
	
	#3. Create temporary directory
	temp_dir = ''
	def_temp_dir = tempfile.TemporaryDirectory(prefix='pdftools') #avoid out of scope
	#If NOT in debug, temporary directory is created in system temporary folder
	if not args.debug:
		temp_dir = def_temp_dir.name
	#If in debug mode, temporary directory is created in current working directory
	else:
		temp_dir = os.path.join(os.getcwd(), args.debug_folder)
		if not os.path.isdir(temp_dir):
			os.mkdir(temp_dir)
	os.chdir(temp_dir) #Change working directory to the temp folder. In this way, latex temporary files are created there
	
	#4. ******* Pre-compiling **********
	
	#-Latex input and pdf output file
	latex_file_name = "latex_file.tex" #Relative path
	latex_pdf_name = os.path.join(temp_dir,"latex_file.pdf")
	if(os.path.isfile(latex_file_name)): #Check for existence of the LaTeX file and remove it. Useful in debug mode.
		os.remove(latex_file_name)
		
	#-In landscape mode, rows and columns number for nup are swapped
	if 'landscape' in args.booleans:
		args.nup[0], args.nup[1] = args.nup[1], args.nup[0]
	
	#-Process offset and delta strings
	args.offset[0] = args.offset[0].replace(r'_',r'-')
	args.offset[1] = args.offset[1].replace(r'_',r'-')
	args.delta[0] = args.delta[0].replace(r'_',r'-')
	args.delta[1] = args.delta[1].replace(r'_',r'-')
	
	#-Reverse trim is used with "split pages". args.trim contains the left page, reverse_trim contains the right page
	reverse_trim = [ args.trim[2] , args.trim[3] , args.trim[0] , args.trim[1] ]
		
	#-Insert a white page after every pdf page
	if(args.white_page):
		args.pages = r"{\theit,{}}"
	if(args.split_pages):
		args.pages = r"{\theit}"
	
	#-Get size of the first page of the input pdf. Define \pdfwidth and \pdfheight
	pre_include_pdf += "%Get dimensions of pdf page" \
	"\n\t\\savebox{\\mybox}{\\includegraphics{latex_pdf_filename}}" \
	"\n\t\\settowidth{\\pdfwidth}{\\usebox{\\mybox}}" \
	"\n\t\\settoheight{\\pdfheight}{\\usebox{\\mybox}} \n\t"
	
	#-Loop to include pages one at a time. Use 'latex_pdf_filename' variable
	if(args.white_page or args.split_pages):
		pre_include_pdf += "%Loop adding one single page at a time"\
		"\n\t\\newcounter{it}"\
		"\n\t\\forloop{it}{1}{\\value{it} < \\numexpr \\thepdfpagenum+1} {\n\t"
		post_include_pdf += "} \n"
	
	#-Keep last page even
	if(args.last_page_even):
		post_include_pdf += "\\clearpage"\
		"\n\t\\checkoddpage"\
		"\n\t\\ifoddpage"\
		"\n\t\\else"\
		"\n\t\\hbox{}"\
		"\n\t\\newpage"\
		"\n\t\\fi\n\t"
	
	#********** 5. Create latex script **********
	latex_script = r"\documentclass"
	if(args.paper != ""):
		latex_script += '[' + args.paper + ']'
	latex_script += "{article}"\
	"\n\\usepackage[utf8x]{inputenc}" \
	"\n\\usepackage{grffile} %To avoid problems with pdf filenames. N.B. MUST BE BEFORE PDFPAGES TO AVOID BUG!"\
	"\n\\usepackage{pdfpages, lastpage, fancyhdr, forloop, geometry, calc, graphicx}"\
	"\n\\usepackage[absolute]{textpos}"\
	"\n\\usepackage{changepage} %Implement check to get if current page is odd or even"\
	"\n\\strictpagecheck"\
	"\n\\newcounter{pdfpagenum}"\
	"\n\\newsavebox{\\mybox}"\
	"\n\\newlength{\\pdfwidth}"\
	"\n\\newlength{\\pdfheight}\n"

	#Create a fancy pagestyle for each input files
	for filenum in range(len(input_pdf_files)):
		file_basename = os.path.basename(input_pdf_files[filenum])
		latex_script += "\\fancypagestyle{file_""" + str(filenum) + "}"
		latex_script += "{\n\t\\fancyhf{} % Start with clearing everything in the header and footer"
		latex_script += "\n\t\\renewcommand{\\headrulewidth}{0pt}% No header rule"
		latex_script += "\n\t\\renewcommand{\\footrulewidth}{0pt}% No footer rule\n\t"
		#Process add text
		for text in args.text:
			#print(text[0])
			text_proc = Template(text[0]).substitute(day=today.day, month=today.month, year=today.year, page=r'\thepage', pages=r'\pageref{LastPage}', filename=file_basename)
			text_proc = text_proc.replace(r' ',r'~') #otherwise spaces will get ignored
			text_proc = text_proc.replace(r'_',r'\_') #otherwise error occurs
			#The default position of textpos is the top left page corner. In landscape mode this become the top right corner (rotation of 90 degress clockwise)
			#But we want the units always expressed related to the top left corner. So we convert them.
			if 'landscape' in args.booleans:
				text[1], text[2] = text[2], text[1] #swap them
				text_proc = "\\rotatebox{90}{"+text_proc+"}"
			#textblock wants the position of the upper left corner of the text box. Starred version requires positions expressed as length (not relative to TPHorizModule)
			latex_script += "\\begin{textblock*}{\\paperwidth}("+str(text[1])+"\\paperwidth, "+str(text[2])+"\\paperheight)\n\t\t\\raggedright "+text_proc+"\n\t\\end{textblock*}\n\t"
		latex_script += "} %end of fancypagestyle\n"
	
	latex_script += "\\begin{document}\n\t";
	
	#Insert input image files in latex script
	for filenum in range(len(input_img_files)):
		f = input_img_files[filenum]
		f = linuxize(f)
		latex_script += "\\begin{figure}"\
		"\n\\includegraphics[width=\\linewidth]{"+f+"}"\
		"\n\\end{figure}"
		
	#Insert input PDF files in latex script
	for filenum in range(len(input_pdf_files)):
		f = input_pdf_files[filenum]
		pagestyle = "file_"+str(filenum)
		#print("Adding file to latex: \"" + f + "\"")
		latex_pdf_filename = r"\detokenize{" + linuxize(f) + "}"

		#Page numbers are needed on some pre include scripts (e.g. white pages)
		latex_script += "%Get the number of pdf pages"\
		"\n\t\\pdfximage{"""+latex_pdf_filename+"}"\
		"\n\t\\setcounter{pdfpagenum}{\\pdflastximagepages}\n\t"

		#Pre-include script (e.g. insert a white page after every logical page). Substitute latex_pdf_filename variable
		latex_script += pre_include_pdf.replace(r"latex_pdf_filename",latex_pdf_filename)
		
		#Include the pdf
		include_pdf_str = "%Importing the pdf \n \t"
		include_pdf_str = "\\includepdf[keepaspectratio, pages=$pages"

		if(args.nup != [1,1]):
			include_pdf_str += ",nup="+str(args.nup[1])+"x"+str(args.nup[0])
		
		if(args.delta != ['0','0']):
			include_pdf_str += ",delta="+arrayToString(args.delta)
		
		if(args.offset != ['0','0']):
			include_pdf_str += ",offset="+arrayToString(args.offset)
		
		if(args.trim != ['0','0','0','0']):
			include_pdf_str += ",trim={$trimarray}" #we use this syntax to allow "split pages"
		
		if (args.scale != 0):
			include_pdf_str += ",noautoscale, scale="+str(args.scale)
		if (args.width != 0):
			include_pdf_str += ",width="+str(args.width[0])+r"\paperwidth"
		if (args.height != 0):
			include_pdf_str += ",height="+str(args.height[0])+r"\paperheight"
		include_pdf_str += r",pagecommand=\thispagestyle{"+pagestyle+"}"
		
		#Boolean parameters for pdfpages package
		for boolpar in args.booleans:
			include_pdf_str += r","+boolpar
		
		#Custom arguments for pdfpages package
		if args.custom != None and args.custom != "":
			include_pdf_str += r"," + args.custom
		
		#Finalize with input filename
		include_pdf_str += r"]{"+latex_pdf_filename+"} \n\t"; #DO NOT PUT SPACES IN FILENAMES. THE FILENAME IS GET AS IT, VERY LITERALLY
		
		#Swap pages
		if(args.swap_pages):
			pag_list = list()
			for p in args.pages.split(","):
				pag_list.append(int(p))			
			#Find maximum value
			maxv = max(pag_list)
			pages = list()
			for n in range(1,maxv+1): #right limit is excluded
				pages.append(n)
			#print(pages)
			#print(pag_list)
			for p in range(0,len(pag_list),2):
				pages[pag_list[p]-1], pages[pag_list[p+1]-1] = pag_list[p+1], pag_list[p]
			pages.append(maxv+1)
			for p in pages:
				if(p is not pages[0]):
					args.pages += "," 
				args.pages += str(p)
			args.pages+="-"
			#print(args.pages)
			
		#Extract pages
		if(args.extract_pages):
			pag_list = readListFromFile(args.pages_list)
			pag_list.sort()
			print("Extractin the following pages: "+pag_list)
			for p in pag_list:
				if(p is not pag_list[0]):
					args.pages += "," 
				args.pages += str(p)
				
		#-Adjust pages syntax	
		if(args.pages[0] != "{"): #Avoids to get page={{{{-}}}} when merging multiple pdf files together
			args.pages = "{" + args.pages + "}"
		
		#Add include_pdf_str to latex_script
		inc_pdf_temp = Template(include_pdf_str)
		inc_pdf_fin1 = inc_pdf_temp.safe_substitute(trimarray=arrayToString(args.trim, "{", "}"),pages=args.pages)
		latex_script += inc_pdf_fin1
		
		#Split pages
		if(args.split_pages):
			inc_pdf_fin2 = inc_pdf_temp.safe_substitute(trimarray=arrayToString(reverse_trim,"{", "}"))
			latex_script += inc_pdf_fin2
		
		latex_script += post_include_pdf
	
	#END OF FOR LOOP FOR MULTIPLE INPUT FILES
	
	#Post-include pdf
	latex_script += r'\end{document}'
	
	#Write latex file
	latex_file = open(latex_file_name,"w")
	latex_file.write(latex_script)
	latex_file.close()
	
	#Compile
	if not args.debug_no_compile:
		for i in range(needed_comp_rounds):
			print("Compilation round: " + str(i+1) + "/" + str(needed_comp_rounds))
			#Python 3.3 and higher support subprocess.DEVNULL to suppress output. 
			#See (http://stackoverflow.com/questions/699325/suppress-output-in-python-calls-to-executables)
			latex_return = subprocess.call( ["pdflatex","--interaction=batchmode",""+latex_file_name] , stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
			if latex_return != 0 or os.path.getsize('latex_file.pdf')==0:
				if args.debug:
					#We are currently into the temporary folder
					zip_file = zipfile.ZipFile('report.zip', 'w')
					zip_file.write('latex_file.tex')
					if(os.path.isfile('latex_file.log')):
						zip_file.write('latex_file.log')
					zip_file.close()
					return exit_with_code("Latex failed to compile the file. Debug report was generated", 1)
				else:
					exit_with_code("Latex failed to compile the file. Please run again with --debug option, then report at https://github.com/raffamaiden/pdftools/issues attaching ./temp/report.gz", 1)
		#** End of all compilation rounds (for loop) **
		#Copy resulting pdf file from temporary folder to output directory
		shutil.copyfile(latex_pdf_name, args.output)
	
	#Open output pdf
	if args.open:
		openFile("\""+args.output+"\"")
		
	#exit_with_code("",0) #must be put there because temporary folder will be deleted at the end of this function
	os.chdir(previous_cwd)

def main(cmdargs):
	#Check for pdflatex to be in path
	try:
		pdflatex_return = subprocess.call( ['pdflatex','--version'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)		
	except FileNotFoundError:
		exit_with_code("Pdflatex is not in path. Please install a Latex distribution and make sure pdflatex is in path", 1)		
	#Check for pdftk to be in path
	try:
		pdftk_return = subprocess.call( ['pdftk','--version'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)		
	except FileNotFoundError:
		print("Warning: pdftk was not found")
		pdftk=False
	#Check for pdfcrop to be in path
	pdfcrop=True
	try:
		pdftk_return = subprocess.call( ['pdfcrop','--version'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)		
	except FileNotFoundError:
		print("Warning: pdfcrop was not found")
		pdfcrop=False
	
	#Get command line options
	parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
	
	parser.add_argument('-i', '--input', action='append', required=False, help=u'Input pdf file. Use this flag again to merge multiple pdf files into one. You can also pass a directory, in which case all pdf files inside it are merged togheter, sorted in alphabetical filename order.')
	#A mutually exclusive group to specify the output file name OR a suffix to append to the first input file name
	output_group = parser.add_mutually_exclusive_group()
	output_group.add_argument('-o', '--output', help=u'Output filename')
	output_group.add_argument('--out-suffix', help=u'Suffix to add to the first input filename to obtain the output filename', default='_pdftools')	
	#Vector parameters
	parser.add_argument('--paper', type=str, default='a4paper', metavar=('PAPER_TYPE'), help=u'Specify paper type. Can be: a4paper, letterpaper,'\
		'a5paper, b5paper, executivepaper, legalpaper. To use the same format of input pdf file, use --fitpaper option.')
	parser.add_argument('--scale', nargs=1, type=float, default=0, metavar=('SCALE_FACTOR'), help=u'Scales the image by the desired scale factor. ' \
		'E.g, 0.5 to reduce by half, or 2 to double. 0 means auto-scaling (default)')
	parser.add_argument('--width', nargs=1, type=float, default=0, metavar=('WIDTH'), help=u'Width of 1 input page (take care of this in case of n-upping) '
		'relative to output page width.')
	parser.add_argument('--height', nargs=1, type=float, default=0, metavar=('HEIGHT'), help=u'Height of 1 input page (take care of this in case of n-upping)' \
		'relative to output page height.')	
	parser.add_argument('--nup', nargs=2, type=int,   default=[1,1], metavar=('ROWS', 'COLS'), help=u'Nup pages, follow with number of rows and columns')
	
	parser.add_argument('--offset', nargs=2, type=str, default=['0','0'], metavar=('RIGHT', 'TOP'), help=u'The inserted logical pages are being centered ' \
		'on the sheet of paper by default. To displace them use the offset option, which argument should be two dimensions. E.g. offset=10mm 14mm means that the logical' \
		'pages are displaced by 10 mm in horizontal direction and by 14 mm in vertical direction. In oneside documents, positive values shift the pages to the right and to' \
		'the top margin, respectively, whereas in ‘twoside’ documents, positive values shift the pages to the outer and to the top margin, respectively.')
		
	parser.add_argument('--trim', nargs=4, type=str, default=['0','0','0','0'], metavar=('Left', 'Bottom', 'Right', 'Top'), help=u'Crop pdf page. ' \
		'You can use the following variables: \pdfwidth is the width of a pdf page, \pdfheight is the height of a pdf page. Both are calculated on the first page of the pdf. So for example "--trim 0 .5\pdfwidth .2\pdfheight 0" will trim the pages half from the right and 20 per cent from the bottom') 
	parser.add_argument('--delta',  nargs=2, type=str, default=['0','0'], metavar=('X', 'Y'), help=u'By default logical pages are being arranged side by side.' \
		'To put some space between them, use the delta option, whose argument should be two dimensions.')
	parser.add_argument('--custom', help=u'Custom pdfpages options')
	parser.add_argument('--pages', default="-", help=u'Selects pages to insert. The argument is a comma separated list, containing page numbers '\
		'(e.g. --pages 3,5,6,8), ranges of page numbers (e.g. --pages 4-9) or any combination fo the previous.'\
		'To insert empty pages use {}. '\
		'Page ranges are specified by the following syntax: m-n. This selects'\
		'all pages from m to n. Omitting m defaults to the first page; omitting'\
		'n defaults to the last page of the document. Another way to select' \
		'the last page of the document, is to use the keyword last.' \
		'E.g.: "--pages 3,{},8-11,15" will insert page 3, an empty page, pages from 8 to 11, and page 15. '\
		'"--pages=-" will insert all pages of the document, and "--pages=last-1"' \
		'will insert all pages in reverse order.')
	parser.add_argument('-t', '--text', nargs=3, type=str, action='append', metavar=('text_string', 'hpos', 'vpos'), help=u'Add text to pdf file. text_string is the string to add, special variables can be passed. Call --text-help for help on how to build string. hpos and vpos are numbers between 0 and 1 that represents the coordinates of the top left corner of the bounding box that surronds the text relative to the top left corner of the page.')
	parser.add_argument('--text-help', action='store_true', help=u'Print help to build a text string to pass to -t/--text option')
	
	#Boolean parameters NOT for pdfpages
	parser.add_argument('--natural-sorting', action='store_true', default=False, help=u'When scanning a folder, use natural sorting algorithm to sort the files inside it')
	parser.add_argument('--overwrite', action='store_true', default=False, help=u'Overwrite output file if it exists already')
	parser.add_argument('--open', action='store_true', default=False, help=u'Open output PDF file')
	parser.add_argument('--white-page', action='store_true', default=False, help=u'Put a white page after every pdf page')
	parser.add_argument('--repair', action='store_true', default=False, help=u'Try to repair the input PDF files. You need pdftk for this')
	parser.add_argument('--check-latex', action='store_true', default=False, help=u'Check LaTeX installation')
	parser.add_argument('--split-pages', action='store_true', default=False, help=u'Split every input page in 2 equal output pages. '\
		'Use it, for example, if you have a pdf which consists of 2 physical pages in 1 pdf page and you want to split them. Use it on conjuction with trim,'\
		'with which you will specify the left page. If you specify --trim L B R T, the left page will be obtained by trimming with {L B R T}, '\
		'while the right page will be obtained by trimming with {R f L B} (note the swap in left-right and in top-bottom). Use \pdfwidth and \pdfheight '\
		'paramenters in trim option to specify trim relative to page size')
	parser.add_argument('--swap-pages', action='store_true', default=False, help=u'--pages-list specify a text file with a space-separated list of pages to swap')
	parser.add_argument('--extract-pages', action='store_true', default=False, help=u'Read pages to extract from a text file. In the text file pages can be separated by newline character or by space (or mixed)')
	parser.add_argument('--paginate', action='store_true', default=False, help=u'Alias for --text $page/$pages '+ str(paginate_h) + ' ' + str(paginate_v))
	parser.add_argument('--last-page-even', action='store_true', default=False, help=u'Last page of every included pdf must be even.'\
		'If it is odd, add a white page')
		
	#Boolean parameters TO PASS TO PDFPAGES (AND ONLY FOR PSDFPAGES)
	parser.add_argument('--clip', action='append_const', const='clip', dest='booleans', help=u'Used togheter with trim, will actually remove the cropped '\
		'part from the pdfpage. If false, the cropped part is present on the physical file, but the pdf reader is instructed to ignore it')
	parser.add_argument('--landscape', action='append_const', const='landscape', dest='booleans', help=u'Output file is in landscape layer instead of portrait')
	parser.add_argument('--frame', action='append_const', const='frame', dest='booleans', help=u'Put a frame around every logical page')
	parser.add_argument('--fitpaper', action='append_const', const='fitpaper', dest='booleans', help=u'Adjusts the paper size to the one of the inserted document')
	
	#-Debug options-
	#Create temporary folder in the current working directory instead of system's default path for temporary files
	parser.add_argument('--verbose', action='store_true', default=False, help=argparse.SUPPRESS)
	parser.add_argument('--debug', action='store_true', default=False, help=argparse.SUPPRESS)
	#Print the result of parse_args' and exit
	parser.add_argument('--debug-print', action='store_true', default= False, help=argparse.SUPPRESS)
	#Don't compile the resulting latex file
	parser.add_argument('--debug-no-compile', action='store_true', default= False, help=argparse.SUPPRESS)
	#Specify debug folder
	parser.add_argument('--debug-folder', type=str, default='temp', help=argparse.SUPPRESS)	
	
	#Parse arguments
	args = parser.parse_args(cmdargs)
	print("Preprocessing...")
	
	if(args.verbose):
		print(args)
	
	if(args.text_help):
		printTextHelp()
		exit_with_code("",0)
	
	#Build args.text as list if not defined, otherwise crash/we need to make a test every time
	if(args.text is None):
		args.text=list()
	if(args.booleans is None):
		args.booleans=list()
	
	#Process aliases
	if(args.paginate):
		args.text.append(["$page/$pages",paginate_h,paginate_v]);
	
	run(args)
	
if __name__ == "__main__":
	main(sys.argv[1:])